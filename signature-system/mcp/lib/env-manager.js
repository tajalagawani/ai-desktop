/**
 * Environment Manager
 * Manages .env file operations for storing tokens securely
 */

import fs from 'fs/promises';

export class EnvManager {
  constructor(envPath = '.env') {
    this.envPath = envPath;
  }

  /**
   * Read all environment variables from .env file
   */
  async read() {
    try {
      const content = await fs.readFile(this.envPath, 'utf-8');
      return this._parseEnv(content);
    } catch (error) {
      if (error.code === 'ENOENT') {
        return {}; // File doesn't exist yet
      }
      throw error;
    }
  }

  /**
   * Write environment variables to .env file
   */
  async write(env) {
    const content = this._stringifyEnv(env);
    await fs.writeFile(this.envPath, content, 'utf-8');
  }

  /**
   * Set a single environment variable
   */
  async set(key, value) {
    const env = await this.read();
    env[key] = value;
    await this.write(env);
    process.env[key] = value;
  }

  /**
   * Get a single environment variable
   */
  async get(key) {
    const env = await this.read();
    return env[key] || process.env[key];
  }

  /**
   * Delete a single environment variable
   */
  async delete(key) {
    const env = await this.read();
    delete env[key];
    await this.write(env);
    delete process.env[key];
  }

  /**
   * Set multiple environment variables for a node
   */
  async setNodeAuth(nodeType, authData) {
    const env = await this.read();
    const envKeys = [];

    for (const [key, value] of Object.entries(authData)) {
      const envKey = `${nodeType.toUpperCase()}_${key.toUpperCase()}`;
      env[envKey] = value;
      process.env[envKey] = value;
      envKeys.push(envKey);
    }

    await this.write(env);
    return envKeys;
  }

  /**
   * Delete all environment variables for a node
   */
  async deleteNodeAuth(nodeType) {
    const env = await this.read();
    const prefix = `${nodeType.toUpperCase()}_`;
    const keysToDelete = Object.keys(env).filter(key => key.startsWith(prefix));

    for (const key of keysToDelete) {
      delete env[key];
      delete process.env[key];
    }

    await this.write(env);
    return keysToDelete;
  }

  /**
   * Parse .env file content into object
   */
  _parseEnv(content) {
    const env = {};
    const lines = content.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.trim().startsWith('#')) {
        continue;
      }

      const match = line.match(/^([^=]+)=(.*)$/);
      if (match) {
        const key = match[1].trim();
        let value = match[2].trim();

        // Remove quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }

        env[key] = value;
      }
    }

    return env;
  }

  /**
   * Convert object to .env file format
   */
  _stringifyEnv(env) {
    const lines = [
      '# Flow Architect Environment Variables',
      '# Auto-generated by MCP Server',
      '# Last updated: ' + new Date().toISOString(),
      ''
    ];

    // Group by node type
    const grouped = {};
    const ungrouped = [];

    for (const [key, value] of Object.entries(env)) {
      const nodeMatch = key.match(/^([A-Z]+)_/);
      if (nodeMatch) {
        const nodeType = nodeMatch[1].toLowerCase();
        if (!grouped[nodeType]) {
          grouped[nodeType] = [];
        }
        grouped[nodeType].push([key, value]);
      } else {
        ungrouped.push([key, value]);
      }
    }

    // Write grouped vars
    for (const [nodeType, vars] of Object.entries(grouped)) {
      lines.push(`# ${nodeType.toUpperCase()} Node`);
      for (const [key, value] of vars) {
        const needsQuotes = /[\s#]/.test(value);
        lines.push(`${key}=${needsQuotes ? `"${value}"` : value}`);
      }
      lines.push('');
    }

    // Write ungrouped vars
    if (ungrouped.length > 0) {
      lines.push('# Other Variables');
      for (const [key, value] of ungrouped) {
        const needsQuotes = /[\s#]/.test(value);
        lines.push(`${key}=${needsQuotes ? `"${value}"` : value}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Load .env file into process.env
   */
  async loadIntoProcess() {
    const env = await this.read();
    for (const [key, value] of Object.entries(env)) {
      if (!(key in process.env)) {
        process.env[key] = value;
      }
    }
  }
}
