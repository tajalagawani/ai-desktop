[parameters]
github_token = "{{.env.GITHUB_TOKEN}}"
github_owner = "your-github-owner"
github_repo = "your-repo-name"
openai_api_key = "{{.env.OPENAI_API_KEY}}"
openai_model = "gpt-4"
slack_bot_token = "{{.env.SLACK_BOT_TOKEN}}"
slack_channel = "#pull-requests"
redis_host = "localhost"
redis_port = 6379
check_interval_minutes = 5

[node:CheckRedisConnection]
type = redis
label = 1. Connect to Redis for state tracking
operation = ping
host = {{.Parameter.redis_host}}
port = {{.Parameter.redis_port}}

[node:ValidateTokenScopes]
type = py
label = 1.1. Validate GitHub token scopes
code = """
def validate_token(**kwargs):
    import requests

    token = kwargs.get('__parameters__', {}).get('github_token', '')

    # Check GitHub token scopes
    headers = {
        'Authorization': f'token {token}',
        'Accept': 'application/vnd.github.v3+json'
    }

    try:
        response = requests.get('https://api.github.com/user', headers=headers)

        if response.status_code != 200:
            return {
                'result': {
                    'valid': False,
                    'error': 'Invalid GitHub token'
                }
            }

        # Check OAuth scopes
        scopes = response.headers.get('X-OAuth-Scopes', '').split(', ')
        required_scopes = {'repo', 'write:discussion'}  # Minimum required

        has_required = any(scope in scopes for scope in required_scopes)

        return {
            'result': {
                'valid': has_required,
                'scopes': scopes,
                'missing_scopes': list(required_scopes - set(scopes)) if not has_required else []
            }
        }
    except Exception as e:
        return {
            'result': {
                'valid': False,
                'error': str(e)
            }
        }
"""
function = validate_token

[node:ScheduleMonitoring]
type = timer
label = 2. Check for new PRs every 5 minutes
schedule = */{{.Parameter.check_interval_minutes}} * * * *
mode = cron
timezone = UTC
handler = FetchOpenPRs

[node:ScheduleCleanup]
type = timer
label = 2.1. Clean up closed PRs daily
schedule = 0 2 * * *
mode = cron
timezone = UTC
handler = FetchClosedPRs

[node:FetchOpenPRs]
type = github
label = 3. Fetch all open pull requests
operation = list_pull_requests
owner = {{.Parameter.github_owner}}
repo = {{.Parameter.github_repo}}
state = open
token = {{.Parameter.github_token}}

[node:GetProcessedPRs]
type = redis
label = 4. Get list of already processed PRs
operation = smembers
host = {{.Parameter.redis_host}}
port = {{.Parameter.redis_port}}
key = github_pr_review:processed_prs

[node:FilterNewPRs]
type = py
label = 5. Filter out already processed PRs
code = """
def filter_new_prs(**kwargs):
    import json

    # Get open PRs from GitHub
    github_response = kwargs.get('FetchOpenPRs', {})
    all_prs = github_response.get('result', [])

    # Get processed PRs from Redis (now returns a set/list directly)
    processed_response = kwargs.get('GetProcessedPRs', {})
    processed_data = processed_response.get('result', [])

    # smembers returns a list, convert to integers for comparison
    try:
        if isinstance(processed_data, (list, set)):
            processed_pr_ids = [int(x) for x in processed_data if x]
        else:
            processed_pr_ids = []
    except:
        processed_pr_ids = []

    # Filter new PRs with cost-saving filters
    new_prs = []
    skipped_draft = 0
    skipped_wip = 0

    for pr in all_prs:
        pr_number = pr.get('number')
        pr_title = pr.get('title', '')
        is_draft = pr.get('draft', False)

        # Skip if already processed
        if pr_number in processed_pr_ids:
            continue

        # Skip draft PRs to save costs
        if is_draft:
            skipped_draft += 1
            continue

        # Skip WIP (Work In Progress) PRs
        if pr_title.upper().startswith(('WIP', 'WIP:', '[WIP]', 'DRAFT', '[DRAFT]')):
            skipped_wip += 1
            continue

        new_prs.append(pr)

    return {
        'result': {
            'new_prs': new_prs,
            'count': len(new_prs),
            'has_new_prs': len(new_prs) > 0,
            'skipped_draft': skipped_draft,
            'skipped_wip': skipped_wip
        }
    }
"""
function = filter_new_prs

[node:CheckIfNewPRs]
type = if
label = 6. Check if there are new PRs to review
condition = {{FilterNewPRs.result.has_new_prs}} == true
on_true = IterateNewPRs
on_false = LogNoNewPRs

[node:LogNoNewPRs]
type = py
label = 6.1. Log no new PRs found
code = """
def log_no_prs(**kwargs):
    from datetime import datetime
    return {
        'result': {
            'message': 'No new PRs found',
            'timestamp': datetime.utcnow().isoformat()
        }
    }
"""
function = log_no_prs

[node:IterateNewPRs]
type = loop
label = 7. Iterate through each new PR
items = {{FilterNewPRs.result.new_prs}}
handler = ProcessSinglePR

[node:ProcessSinglePR]
type = py
label = 7.1. Extract PR data for processing
code = """
def process_single_pr(**kwargs):
    # Get the current PR from the loop iteration
    pr = kwargs.get('__loop_item__', {})

    return {
        'result': {
            'pr_number': pr.get('number'),
            'pr_title': pr.get('title'),
            'pr_url': pr.get('html_url'),
            'pr_author': pr.get('user', {}).get('login'),
            'pr_body': pr.get('body', ''),
            'pr_created_at': pr.get('created_at'),
            'pr_updated_at': pr.get('updated_at')
        }
    }
"""
function = process_single_pr

[node:ReviewPRWithOpenAI]
type = openai
label = 8. Review PR using OpenAI GPT-4
operation = chat_completion
api_key = {{.Parameter.openai_api_key}}
model = {{.Parameter.openai_model}}
messages = [
    {
        "role": "system",
        "content": "You are an expert code reviewer. Analyze the pull request and provide constructive feedback covering: 1) Code quality and best practices, 2) Potential bugs or issues, 3) Security concerns, 4) Performance considerations, 5) Suggestions for improvement. Be concise but thorough."
    },
    {
        "role": "user",
        "content": "Review this PR:\n\nTitle: {{ProcessSinglePR.result.pr_title}}\n\nDescription: {{ProcessSinglePR.result.pr_body}}\n\nAuthor: {{ProcessSinglePR.result.pr_author}}\n\nProvide a structured review."
    }
]
temperature = 0.3
max_tokens = 1500

[node:GetPRDiff]
type = github
label = 9. Fetch PR diff for detailed review
operation = get_pull_request_diff
owner = {{.Parameter.github_owner}}
repo = {{.Parameter.github_repo}}
pull_number = {{ProcessSinglePR.result.pr_number}}
token = {{.Parameter.github_token}}

[node:CheckDiffSize]
type = py
label = 9.1. Validate diff size before sending to OpenAI
code = """
def check_diff_size(**kwargs):
    diff = kwargs.get('GetPRDiff', {}).get('result', '')

    # Calculate diff size
    diff_size = len(diff)
    line_count = diff.count('\n')

    # Set limits (adjust as needed)
    MAX_DIFF_SIZE = 50000  # 50KB
    MAX_LINE_COUNT = 1000

    is_valid = diff_size <= MAX_DIFF_SIZE and line_count <= MAX_LINE_COUNT

    return {
        'result': {
            'is_valid': is_valid,
            'diff_size': diff_size,
            'line_count': line_count,
            'diff': diff if is_valid else diff[:MAX_DIFF_SIZE] + '\n\n[... diff truncated due to size ...]',
            'truncated': not is_valid
        }
    }
"""
function = check_diff_size

[node:CheckDiffSizeValid]
type = if
label = 9.2. Check if diff is within size limits
condition = {{CheckDiffSize.result.is_valid}} == true
on_true = DetailedCodeReview
on_false = SkipDetailedReview

[node:SkipDetailedReview]
type = py
label = 9.3. Skip detailed review for large diffs
code = """
def skip_review(**kwargs):
    diff_info = kwargs.get('CheckDiffSize', {}).get('result', {})
    return {
        'result': {
            'choices': [{
                'message': {
                    'content': f"âš ï¸ Diff too large for detailed review (Size: {diff_info.get('diff_size', 0)} bytes, Lines: {diff_info.get('line_count', 0)}). Please review manually."
                }
            }]
        }
    }
"""
function = skip_review

[node:DetailedCodeReview]
type = openai
label = 10. Detailed code review with diff
operation = chat_completion
api_key = {{.Parameter.openai_api_key}}
model = {{.Parameter.openai_model}}
messages = [
    {
        "role": "system",
        "content": "You are a senior code reviewer. Analyze the code diff and provide specific, actionable feedback. Focus on: bugs, security vulnerabilities, performance issues, code smells, and best practices violations."
    },
    {
        "role": "user",
        "content": "Review this code diff:\n\n```diff\n{{CheckDiffSize.result.diff}}\n```\n\nProvide line-specific feedback where applicable."
    }
]
temperature = 0.3
max_tokens = 2000

[node:FormatReviewMessage]
type = py
label = 11. Format review for Slack
code = """
def format_review(**kwargs):
    import json

    pr_data = kwargs.get('ProcessSinglePR', {}).get('result', {})
    openai_review = kwargs.get('ReviewPRWithOpenAI', {}).get('result', {})
    detailed_review = kwargs.get('DetailedCodeReview', {}).get('result', {})

    # Extract OpenAI response
    review_content = openai_review.get('choices', [{}])[0].get('message', {}).get('content', 'No review generated')
    detailed_content = detailed_review.get('choices', [{}])[0].get('message', {}).get('content', 'No detailed review')

    # Format Slack message
    slack_message = f"""
ðŸ” *New Pull Request Review*

*PR #{pr_data.get('pr_number')}: {pr_data.get('pr_title')}*
ðŸ‘¤ Author: {pr_data.get('pr_author')}
ðŸ”— Link: {pr_data.get('pr_url')}

ðŸ“ *AI Review Summary:*
{review_content}

ðŸ”¬ *Detailed Code Analysis:*
{detailed_content}

---
_Automated review by OpenAI GPT-4_
    """.strip()

    return {
        'result': {
            'message': slack_message,
            'pr_number': pr_data.get('pr_number'),
            'pr_url': pr_data.get('pr_url')
        }
    }
"""
function = format_review

[node:SendSlackNotification]
type = slack
label = 12. Send review to Slack
operation = post_message
token = {{.Parameter.slack_bot_token}}
channel = {{.Parameter.slack_channel}}
text = {{FormatReviewMessage.result.message}}

[node:PostReviewAsComment]
type = github
label = 13. Post review as PR comment
operation = create_issue_comment
owner = {{.Parameter.github_owner}}
repo = {{.Parameter.github_repo}}
issue_number = {{FormatReviewMessage.result.pr_number}}
body = "## ðŸ¤– AI Code Review\n\n{{ReviewPRWithOpenAI.result.choices[0].message.content}}\n\n### Detailed Analysis\n\n{{DetailedCodeReview.result.choices[0].message.content}}\n\n---\n*Automated review generated by OpenAI GPT-4*"
token = {{.Parameter.github_token}}

[node:MarkPRAsProcessed]
type = redis
label = 14. Mark PR as processed
operation = sadd
host = {{.Parameter.redis_host}}
port = {{.Parameter.redis_port}}
key = github_pr_review:processed_prs
member = {{FormatReviewMessage.result.pr_number}}

[node:LogSuccess]
type = py
label = 15. Log successful review
code = """
def log_success(**kwargs):
    from datetime import datetime

    pr_data = kwargs.get('FormatReviewMessage', {}).get('result', {})

    return {
        'result': {
            'status': 'success',
            'pr_number': pr_data.get('pr_number'),
            'pr_url': pr_data.get('pr_url'),
            'reviewed_at': datetime.utcnow().isoformat()
        }
    }
"""
function = log_success

[node:HandleAPIError]
type = py
label = Error.1. Handle API failures
code = """
def handle_error(**kwargs):
    from datetime import datetime
    import traceback

    pr_data = kwargs.get('ProcessSinglePR', {}).get('result', {})
    error_info = kwargs.get('__error__', {})

    return {
        'result': {
            'status': 'error',
            'pr_number': pr_data.get('pr_number'),
            'error_message': str(error_info.get('message', 'Unknown error')),
            'error_type': error_info.get('type', 'unknown'),
            'timestamp': datetime.utcnow().isoformat(),
            'should_retry': error_info.get('type') in ['rate_limit', 'timeout', 'network']
        }
    }
"""
function = handle_error

[node:LogAPIError]
type = py
label = Error.2. Log API error
code = """
def log_error(**kwargs):
    from datetime import datetime
    error_data = kwargs.get('HandleAPIError', {}).get('result', {})

    print(f"[ERROR] PR Review Failed: PR #{error_data.get('pr_number')} - {error_data.get('error_message')}")

    return {
        'result': {
            'logged': True,
            'timestamp': datetime.utcnow().isoformat()
        }
    }
"""
function = log_error

[node:CheckRetryEligible]
type = if
label = Error.3. Check if error is retryable
condition = {{HandleAPIError.result.should_retry}} == true
on_true = WaitBeforeRetry
on_false = MarkAsFailedPR

[node:WaitBeforeRetry]
type = py
label = Error.4. Exponential backoff wait
code = """
def wait_backoff(**kwargs):
    import time

    # Get retry attempt (default to 1)
    retry_count = kwargs.get('__retry_count__', 1)

    # Exponential backoff: 2^retry_count seconds (max 60s)
    wait_time = min(2 ** retry_count, 60)

    return {
        'result': {
            'wait_seconds': wait_time,
            'retry_count': retry_count,
            'next_retry': retry_count + 1
        }
    }
"""
function = wait_backoff

[node:MarkAsFailedPR]
type = redis
label = Error.5. Mark PR as failed (don't retry)
operation = sadd
host = {{.Parameter.redis_host}}
port = {{.Parameter.redis_port}}
key = github_pr_review:failed_prs
member = {{ProcessSinglePR.result.pr_number}}

[node:FetchClosedPRs]
type = github
label = Cleanup.1. Fetch all closed PRs
operation = list_pull_requests
owner = {{.Parameter.github_owner}}
repo = {{.Parameter.github_repo}}
state = closed
token = {{.Parameter.github_token}}

[node:CleanupProcessedPRs]
type = py
label = Cleanup.2. Remove closed PRs from processed list
code = """
def cleanup_closed_prs(**kwargs):
    # Get closed PRs from GitHub
    closed_prs_response = kwargs.get('FetchClosedPRs', {})
    closed_prs = closed_prs_response.get('result', [])

    # Get processed PRs from Redis
    processed_response = kwargs.get('GetProcessedPRsForCleanup', {})
    processed_pr_ids = processed_response.get('result', [])

    # Find PRs to remove (closed PRs that are in processed list)
    closed_pr_numbers = [pr.get('number') for pr in closed_prs]
    to_remove = [str(pr_id) for pr_id in processed_pr_ids if int(pr_id) in closed_pr_numbers]

    return {
        'result': {
            'prs_to_remove': to_remove,
            'count': len(to_remove)
        }
    }
"""
function = cleanup_closed_prs

[node:GetProcessedPRsForCleanup]
type = redis
label = Cleanup.3. Get processed PRs list
operation = smembers
host = {{.Parameter.redis_host}}
port = {{.Parameter.redis_port}}
key = github_pr_review:processed_prs

[node:RemoveClosedPRs]
type = py
label = Cleanup.4. Remove closed PRs from Redis
code = """
def remove_prs(**kwargs):
    import redis

    cleanup_data = kwargs.get('CleanupProcessedPRs', {}).get('result', {})
    prs_to_remove = cleanup_data.get('prs_to_remove', [])

    # Connect to Redis and remove
    redis_host = kwargs.get('__parameters__', {}).get('redis_host', 'localhost')
    redis_port = kwargs.get('__parameters__', {}).get('redis_port', 6379)

    r = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)

    removed_count = 0
    for pr_id in prs_to_remove:
        r.srem('github_pr_review:processed_prs', pr_id)
        removed_count += 1

    return {
        'result': {
            'removed_count': removed_count,
            'message': f'Cleaned up {removed_count} closed PRs from tracking'
        }
    }
"""
function = remove_prs

[node:LogCleanup]
type = py
label = Cleanup.5. Log cleanup results
code = """
def log_cleanup(**kwargs):
    from datetime import datetime

    cleanup_result = kwargs.get('RemoveClosedPRs', {}).get('result', {})

    print(f"[CLEANUP] {cleanup_result.get('message', 'Cleanup completed')}")

    return {
        'result': {
            'status': 'cleanup_completed',
            'timestamp': datetime.utcnow().isoformat(),
            **cleanup_result
        }
    }
"""
function = log_cleanup

[node:DefineHealthCheckRoute]
type = aci
mode = server
label = API.Health.1. GET /api/health
operation = add_route
route_path = /api/health
methods = ["GET"]
handler = GetHealthStatus
description = Health check endpoint

[node:GetHealthStatus]
type = py
label = API.Health.1.1. Return health status
code = """
def health_check(**kwargs):
    from datetime import datetime
    return {
        'result': {
            'status': 'healthy',
            'service': 'github-pr-review-system',
            'timestamp': datetime.utcnow().isoformat()
        }
    }
"""
function = health_check

[node:DefineProcessedPRsRoute]
type = aci
mode = server
label = API.Stats.1. GET /api/processed-prs
operation = add_route
route_path = /api/processed-prs
methods = ["GET"]
handler = GetProcessedPRsList
description = Get list of processed PRs

[node:GetProcessedPRsList]
type = redis
label = API.Stats.1.1. Fetch processed PRs from Redis
operation = smembers
host = {{.Parameter.redis_host}}
port = {{.Parameter.redis_port}}
key = github_pr_review:processed_prs

[node:DefineManualTriggerRoute]
type = aci
mode = server
label = API.Manual.1. POST /api/check-prs
operation = add_route
route_path = /api/check-prs
methods = ["POST"]
handler = ManualCheckPRs
description = Manually trigger PR check

[node:ManualCheckPRs]
type = py
label = API.Manual.1.1. Validate and trigger manual PR check
code = """
def manual_trigger(**kwargs):
    from datetime import datetime
    import re

    # Get request data
    request = kwargs.get('__request__', {})
    body = request.get('body', {})

    # Input validation
    errors = []

    # Validate repo owner (if provided)
    if 'github_owner' in body:
        owner = body.get('github_owner', '')
        if not re.match(r'^[a-zA-Z0-9-]+$', owner):
            errors.append('Invalid github_owner format')

    # Validate repo name (if provided)
    if 'github_repo' in body:
        repo = body.get('github_repo', '')
        if not re.match(r'^[a-zA-Z0-9-_.]+$', repo):
            errors.append('Invalid github_repo format')

    # Check rate limiting (simple in-memory check)
    # In production, use Redis for distributed rate limiting
    last_trigger = kwargs.get('__state__', {}).get('last_manual_trigger', 0)
    current_time = datetime.utcnow().timestamp()

    if current_time - last_trigger < 60:  # 1 minute cooldown
        errors.append('Rate limited: Please wait 60 seconds between manual triggers')

    if errors:
        return {
            'result': {
                'status': 'error',
                'errors': errors,
                'timestamp': datetime.utcnow().isoformat()
            },
            'http_status': 400
        }

    return {
        'result': {
            'status': 'triggered',
            'message': 'Manual PR check initiated',
            'timestamp': datetime.utcnow().isoformat()
        },
        '__state__': {
            'last_manual_trigger': current_time
        }
    }
"""
function = manual_trigger

[edges]
# Initialization
CheckRedisConnection = ValidateTokenScopes
ValidateTokenScopes = ScheduleMonitoring
ValidateTokenScopes = ScheduleCleanup
ValidateTokenScopes = DefineHealthCheckRoute
ValidateTokenScopes = DefineProcessedPRsRoute
ValidateTokenScopes = DefineManualTriggerRoute

# Timer flow
ScheduleMonitoring = []
FetchOpenPRs = GetProcessedPRs

# Cleanup flow
ScheduleCleanup = []
FetchClosedPRs = GetProcessedPRsForCleanup
GetProcessedPRsForCleanup = CleanupProcessedPRs
CleanupProcessedPRs = RemoveClosedPRs
RemoveClosedPRs = LogCleanup
GetProcessedPRs = FilterNewPRs
FilterNewPRs = CheckIfNewPRs
CheckIfNewPRs = []

# No new PRs path
LogNoNewPRs = []

# New PRs processing path (loop handler)
IterateNewPRs = []
ProcessSinglePR = ReviewPRWithOpenAI
ProcessSinglePR = GetPRDiff

# Initial review path
ReviewPRWithOpenAI = GetPRDiff

# Diff size validation
GetPRDiff = CheckDiffSize
CheckDiffSize = CheckDiffSizeValid
CheckDiffSizeValid = []

# Detailed review (either real or skipped)
DetailedCodeReview = FormatReviewMessage
SkipDetailedReview = FormatReviewMessage

# Notification and storage
FormatReviewMessage = SendSlackNotification
FormatReviewMessage = PostReviewAsComment
SendSlackNotification = MarkPRAsProcessed
PostReviewAsComment = MarkPRAsProcessed
MarkPRAsProcessed = LogSuccess

# Error handling paths
HandleAPIError = LogAPIError
LogAPIError = CheckRetryEligible
CheckRetryEligible = []
WaitBeforeRetry = []
MarkAsFailedPR = []

# API routes
DefineHealthCheckRoute = GetHealthStatus
DefineProcessedPRsRoute = GetProcessedPRsList
DefineManualTriggerRoute = ManualCheckPRs

[env]

[settings]
debug_mode = true
max_retries = 3
timeout_seconds = 600

[configuration]
agent_enabled = true
agent_name = github-pr-review-agent
agent_version = 1.0.0
host = 0.0.0.0
port = 9001
debug = true
cors_enabled = true

[deployment]
environment = development
